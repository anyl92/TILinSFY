# 알고리즘

사전적 의미 - 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법이다.

어떠한 문제를 해결하기 위한 절차라고 볼 수 있다. (프로세스)

반드시 시작과 끝이 있다. 끝나지 않으면 알고리즘이라고 할 수 없음.

* 알고리즘을 표현하는 방법

  1. 슈더코드(pseudo-code)

     문법적으로 완벽할 필요는 없음. 보는 사람이 이해할 수 있게, 글로 써 줘도 괜찮음.

     알고리즘을 설명하기 위해서 사용하는 것. 프로그램이 어떻게 동작하는지만 작성.

  2. 순서도

     화살표를 따라 알고리즘이 어떤 순서로 진행되는지 설명해준다. 

     간단한 알고리즘의 경우 순서도가 더 보기 편하다. 보통 슈더코드를 사용한다.

* APS과정의 목표 중의 하나는 보다 좋은 알고리즘을 이해하고 활용하는 것이다.

* 좋은 알고리즘이란?

  1. 정확성: 얼마나 정확하게 동작하는가
  2. 작업량: 얼마나 적은 연산으로 원하는 결과를 얻어내는가
  3. 메모리 사용량: 얼마나 적은 메모리를 사용하는가
  4. 단순성: 얼마나 단순한가
  5. 최적성: 더 이상 개선할 여지없이 최적화되었는가

* 성능은 무엇으로 측정하는가? -> 어떤 알고리즘을 사용해야 하는가? 연산의 수가 적은가

* 알고리즘의 작업량을 표현할 때는 시작 복잡도를 사용한다. 

  * 실제 걸리는 시간을 측정 - 주변 환경에 따라 달라지므로 객관성이 떨어짐
  * <b>실행되는 명령문의 개수를 계산</b>
  * 표현법 - O(n), 오메가(n), 세타(n) 
  * O(n)=n2이라면 적어도 n2정도의 연산은 해야
  * 오메가=n2이라면 최대 n2연산은 해야
  * 세타=n2이라면 빅O와 오메가 사이 수준

* 빅오표기법

  * 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
  * O(3n+2) = O(3n) = O(n) 최고차항 선택, 계수 제거
  * 상수번으로 문제가 해결이 된다 -> O(4) = O(1)



### 1. 배열

자바 : 객체지향 언어이지만 C와의 호환을 위해서 C의 타입을 남겨둔 것이 있음

python에서 list에 append하는 것은 매번 list를 copy해서 추가하는것.. 시간이 오래 걸림

배열의 크기를 크게 잡고 index값 증가시켜주면서 넣는게 속도 향상시켜줄 수있는 방법

* 배열의 필요성

  * 프로그램 내에서 여러 개의 변수가 필요할 때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적일 수 있다.
  * 배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있다.
  * 단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있다.

* compiler 방식:  프로그램의 compile(-> object code로 결과가 나옴) & link(-> .exe, .dll 등의 실행 파일이 생성됨) 과정이 있음 -> 실행 파일을 사용자가 운영체제를 통해 실행시켜야 실행이 됨. 운영체제가 실행의 주체.

  자바의 경우 class가 생성되는데... 그냥 C랑은 좀 다르다

* interpreter 방식: compile 과정 없이 실행된다. 

  파이썬은 구조적으로 대용량 데이터를 고려해서 만들어짐

  * script 언어 : 특정 목적에 맞춰서 만들어진 언어.. 파이썬은 변수 선언해주지 않아도 사용할 수 있다

    PSP, JSP, 같은 건 웹을 위해 만들어진

* basic계열 언어들은 index가 1번부터 시작한다





#### 완전검색

* 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다.
* Brute-force 혹은 generate-and-test 기법이라고도 불리운다.
* 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.
* 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.
* 일단 문제가 주어지면 완전검색기법으로 사고를 해서 접근 한 후 더 좋은 방식을 찾아가는 게 좋다.



* 순열

  6개의 경우 6!만큼 나온다. `nPn = n!`

  서로다른 n개 중 r개를 택하는 순열 nPr  `n*n-1*n-r+1`

  

#### 탐욕적 기법

* 최적해를 구하는 데 사용되는 근시안적인 방법이다.
* 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다. 그것이 최적이라는 보장은 없다.
* 일반적으로 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다.



30page

counts리스트에서 run과 triplet 중에 가능한 것을 조사함

조사에 사용한 데이터 삭제

남은 데이터를 다시 run,triplet 가능한지를 조사함



#### Dinamic Programing는 ad시험까진 안나옴



### 2. 정렬

키값을 가지고 레코드 단위로 움직인다.

대표적인 정렬 방식의 종류

* 버블 정렬 - 실제 알고리즘으로 잘 쓰지는 않음, 시간복잡도 n제곱, 비교와 교환횟수가 상대적으로 더 적음
* 카운팅 정렬 - 키가 되는 것이 정수거나, 정수로 표현할 수 있는 자료에 대해서 적용 가능, 데이터의 범위가 어느 특정 범위에 이르는지 알아야 함. 



