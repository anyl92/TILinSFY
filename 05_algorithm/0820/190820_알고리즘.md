## 스택1

* 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조이다.
* 스택에 저장된 자료는 선형 구조를 갖는다. - 자료 간의 관계가 1:1
* 스택에서 마지막 삽입된 원소의 위치를 top이라 부른다.
* 연산
  * 삽입: push
  * 삭제: pop
  * 공백 확인 : isEmpty
  * top에 있는 원소를 반환, 제거되지는 않음 : peek
* 스택의 push 알고리즘

```python
def push(item):
    s.append(item)
```

* 스택의 pop 알고리즘

```python
def pop():
    if len(s) == 0:
        #underflow
        return
    else:
        return s.pop(-1)
```

* 스택의 peek 알고리즘

```python
def peek():
    if len(s) == 0:
        #underflow
        return
    else:
        return s[-1]
```



collection의 deque? 를 사용하면 리스트에 append 하는 것 보다 속도가 빠르다



* 알고리즘 문제의 종류

결정의 문제 - 답을 Yes , No 로 대답할 수 있는 것

최적화 문제 - 답을 최적으로 구해낼 수 있는 것



* DP(Dynamic Programming)

입력 크기가 작은 부분 문제들을 모두 해결한 후 그 해들을 이용하여 보다 큰 부분 문제들을 해결



## 그래프

그래프는 아이템(사물 또는 추상적 개념)들과 이들 사이의 연결 관계를 표현한다.

* 각각의 요소? vertex(정점) 와 그래프에 포함된 간선의 갯수(edge) 들의 집합으로 표현된다.
* V개의 정점을 가지는 그래프는 최대 V(V-1)/2 간선이 가능
* 선형 자료구조나 트리 자료구조로 표현하기 어려운 N : N 관계를 가지는 원소들 표현에 용이



* 인접 행렬 : 정점들의 갯수만큼 행렬을 만들어서 간선에 해당되는 부분에 대해서 1로 표현
* 인접 리스트 : A->B 각각의 정점에 대해서 어떤 정점이 연결되어 있는지에 대한 정보를 표현
* 간선 배열 : (A, B) (B, A) (B, E) (E, B) ... 연결되어 있는 간선들의 배열



* 그래프의 방향에 따라
* 무향 그래프 - i번째 행의 합 = i번째 열의 합 = Vi의 차수  /행렬이 대칭이다
* 유향 그래프 - 행 i의 합 = Vi의 진출 차수 / 열 i의 합 = Vi의 진입 차수



간선 배열은 프로그래밍의 복잡도가 증가하지만 메모리는 적게 차지한다

* 인접 리스트는 간선 배열과 인접 행렬의 장점을 모아서 만들어짐
* 인접 리스트도 링크드 리스트기 때문에 인접 행렬처럼 사용할 수 있음



* DFS(깊이우선탐색) - 스택

  하나의 정점을 선택하여 그 라인을 쭉 탐색한다 

* BFS(너비우선탐색) - 큐

  하나의 정점에 연결된 정점들을 먼저 탐색하고 다음 정점에서의 연결된 정점들을 탐색한다



```python
v # 방문한 점을 기억하고 있어야 한다
방문표시배열에 표시해주고
스택에넣으면 방문한곳만 스택에들어가있는다
방문하면 팝한다
```

* DFS알고리즘(수정)

```python
visited[], stack[]
DFS(v)
	v 방문;
    visited[v] <- true;
    push(v)
    while(stack is not empty):
        v <- pop(stack);
        while(v의 인접 정점 w):
            if w가 방문하지 않은 정점이라면:
                w 방문
                visited[w] <- true;
                push(w);
end DFS()
```

