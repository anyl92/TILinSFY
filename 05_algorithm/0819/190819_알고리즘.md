# 문자열(string)

#### 컴퓨터에서의 문자표현

* 영어가 대소문자 합쳐서 52가지 이므로 6bit(64가지)면 모두 표현할 수 있다.
* 네트워크가 발전되기 전 미국의 각 지역별로 코드체계가 정해져있었지만 네트워크가 발전하면서 서로간에 정보를 달리 해석하는 문제가 생겼다.
* 혼동을 피하기 위해 1967년 미국에서 만들어진 표준안이 ASCII코드. 7bit 인코딩으로 128문자를 표현하며 33개의 출력 불가능한 제어 문자들과 공백을 비롯한 95개의 출력 가능한 문자로 이루어짐.
* 확장 아스키는 표준 문자 이외의 악센트 문자, 도형 문자, 특수 문자, 특수 기호 등 부가적인 문자를 128개 추가할 수 있게 하는 부호이다. 8bit 사용 - 컴퓨터가 해독할 수 있도록 설계되어 있어야 함
* 오늘날 대부분 ASCII형식을 사용하나 각 국가들이 자국의 문자를 표현하기 위해 코드체계를 만듦.
* 그래서 다국어 처리 표준을 마련한 것이 유니코드.
* 유니코드도 다시 Character Set으로 분류된다. UCS-2, 4를 인식하고 구분해서 구현해야 하는 문제 발생, 적당한 외부 인코딩이 필요하게 되었다.
* 실제로는 대부분 little-endian으로 저장이 된다. 네트웍에서 데이터를 주고받는다던가, 모토로라? IBM? 등등의 어떤 상황에서는 bit-endian으로 저장이 된다. 
* 유니코드 인코딩
  * UTF-8 web, python : 파이썬을 웹과 연동해서 사용하기 쉬움
  * UTF-16 windows, java
  * UTF-32 unix
* C언어에서의 문자열 `/0` delimiter 
  * 문자열은 문자들의 배열 형태로 구현된 응용 자료형
  * 문자열 처리에 필요한 연산을 함수 형태로 제공한다
  * 아스키 코드로 저장한다
* Java에서는 문자열의 길이를 늘릴 수 있다. 
  - 문자열 데이터를 저장, 처리해주는 string 클래스가 존재
  - 문자열 처리에 필요한 연산자를 연산자, 메소드 형태로 제공
  - 유니코드(UTF16, 2byte)로 저장한다
* python 
  * char타입 없음, 텍스트 데이터의 취급방법이 통일되어 있음
  * 문자열은 시퀀스 자료형으로 분류되고, 시퀀스 자료형에서 사용할 수 있는 인덱싱, 슬라이싱 연산들을 사용할 수 있음
  * 문자열은 튜플과 같이 요소값을 변경할 수 없음(immutable)
  * 유니코드(UTF8)로 저장한다
* 문자열 뒤집기
  * 자기 문자열에서 뒤집는 방법 / 새로운 빈 문자열을 만들어 소스의 뒤에서부터 읽어서 만드는



#### 패턴매칭

* 고지식한 패턴 검색 알고리즘 - 브루트 포스
  * 최악의 경우 시간 복잡도는 텍스트의 모든 위치에서 패턴을 비교해야 하므로 O(MN)
* KMP 알고리즘
  * 불일치가 발생한 텍스트 스트링의 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
  * 패턴의 전처리가 필요함, 이 계산이 쉽지가 않을 수 있음. 시간 복잡도는 O(M+N)
  * 중복된 값이 많이 없다면 브루트 포스와 크게 다르지 않을 수도 있다.
* 보이어-무어 알고리즘
  * 찾고자 하는 문자의 뒷부분부터 비교, 오른쪽에서 왼쪽으로 비교
  * 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘, 텍스트 문자를 다 보지 않아도 됨
* 수치화 알고리즘
  * 어떤 문자열을 수로 계산을 한다. 4^0, 4^1, 4^2, ... 
  * 계산 값과 동일한지 확인한 후 맨 왼쪽 자릿수를 빼고 오른쪽의 새로운 자릿수를 더한다.
  * 값이 많아지면 컴퓨터가 계산할 수 없는 범위에 다다르기도 한다
* 카프-라빈 알고리즘
  * 수치화 알고리즘을 보완한 것이다.
  * 